// ============================================================================
// CASINO BUILD CREATION LOGIC IMPLEMENTATION
// Accompanies the PRD: Build Creation Logic - Drop Card on Table Card
// ============================================================================

// Core types and interfaces (simplified for demonstration)
class Card {
  constructor(rank, suit) {
    this.rank = rank;
    this.suit = suit;
    this.value = this.getValue();
  }

  getValue() {
    const rankValues = { 'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 10, 'Q': 10, 'K': 10 };
    return rankValues[this.rank] || 0;
  }
}

class Build {
  constructor(cards, value, owner, buildId = null) {
    this.type = 'build';
    this.cards = cards;
    this.value = value;
    this.owner = owner;
    this.buildId = buildId || this.generateBuildId();
    this.isExtendable = true;
  }

  generateBuildId() {
    return `build-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
}

// ============================================================================
// KEY FUNCTIONS FOR BUILD CREATION LOGIC
// ============================================================================

/**
 * GESTURE DETECTION COMPONENT
 * Handles drag initiation, coordinate tracking, and drop completion
 */
class DragDropManager {
  constructor() {
    this.dropZones = [];
    this.currentDrag = null;
  }

  startDrag(card, player) {
    console.log(`[DRAG] Player ${player + 1} started dragging ${card.rank}${card.suit}`);
    this.currentDrag = { card, player, startTime: Date.now() };
  }

  checkDropZones(x, y) {
    // Priority system: smaller zones (cards) get priority over larger zones (general areas)
    let bestZone = null;
    let closestPriority = Infinity;

    for (const zone of this.dropZones) {
      if (this.isPointInZone(x, y, zone)) {
        const distance = Math.sqrt(Math.pow(x - zone.centerX, 2) + Math.pow(y - zone.centerY, 2));
        const area = zone.width * zone.height;
        const priorityScore = distance + (area > 10000 ? 1000 : 0); // Prefer smaller zones

        console.log(`[DROP ZONE] ${zone.id}: distance=${distance.toFixed(1)}, area=${area}, priority=${priorityScore.toFixed(1)}`);

        if (priorityScore < closestPriority) {
          closestPriority = priorityScore;
          bestZone = zone;
        }
      }
    }

    return bestZone;
  }

  isPointInZone(x, y, zone) {
    // Account for mobile touch tolerance (Â±40px)
    const expandedBounds = {
      x: zone.x - 40,
      y: zone.y - 40,
      width: zone.width + 80,
      height: zone.height + 120
    };

    return x >= expandedBounds.x &&
           x <= expandedBounds.x + expandedBounds.width &&
           y >= expandedBounds.y &&
           y <= expandedBounds.y + expandedBounds.height;
  }

  onDropRelease(dragItem, dropX, dropY) {
    console.log(`[DROP] Released at (${dropX}, ${dropY})`);

    const targetZone = this.checkDropZones(dropX, dropY);

    if (targetZone) {
      console.log(`[DROP] Selected zone: ${targetZone.id}`);
      const result = targetZone.onDrop(dragItem);
      return { handled: true, result };
    } else {
      console.log(`[DROP] No valid zones found - trail card`);
      return { handled: false, result: null };
    }
  }
}

/**
 * VALIDATION ENGINE
 * Enforces game rules and validates moves before execution
 */
class BuildValidator {
  static canCreateBuild(handCard, tableCard, gameState, player) {
    // Card availability checks
    if (!gameState.playerHands[player].some(c => c.rank === handCard.rank && c.suit === handCard.suit)) {
      return { valid: false, message: "Card not in your hand" };
    }

    // Table card existence
    if (!gameState.tableCards.some(c => !c.type && c.rank === tableCard.rank && c.suit === tableCard.suit)) {
      return { valid: false, message: "Target card not found on table" };
    }

    // Turn validation
    if (gameState.currentPlayer !== player) {
      return { valid: false, message: "Not your turn" };
    }

    // Build value calculation
    const buildValue = handCard.value + tableCard.value;

    // Game rule: builds must sum to make sense (basic validation)
    if (buildValue < 3 || buildValue > 31) {
      return { valid: false, message: `Invalid build value: ${buildValue}` };
    }

    return {
      valid: true,
      buildValue,
      message: "Valid build"
    };
  }

  static validateBuildState(gameState, player) {
    // Check that player can only have one active build at a time (Round 2 rule)
    const existingTempBuilds = gameState.tableCards.filter(card =>
      card.type === 'temporary_stack' && card.owner === player
    );

    if (existingTempBuilds.length > 0) {
      return { valid: false, message: "You can only have one active build at a time" };
    }

    return { valid: true };
  }
}

/**
 * BUILD FACTORY
 * Creates and manages build objects with proper properties
 */
class BuildFactory {
  static createBuildFromCards(handCard, tableCard, player) {
    // Sort cards: bigger cards first (top of stack)
    const cards = [handCard, tableCard].sort((a, b) => b.value - a.value);
    const buildValue = handCard.value + tableCard.value;

    const build = new Build(cards, buildValue, player);

    console.log(`[BUILD] Created ${build.buildId} with value ${buildValue} owned by player ${player + 1}`);
    console.log(`[BUILD] Cards: ${cards.map(c => c.rank + c.suit).join(', ')}`);

    return build;
  }
}

/**
 * STATE MANAGER
 * Handles atomic game state updates and maintains consistency
 */
class GameStateManager {
  static executeBuild(dragItem, targetCard, gameState) {
    const { card: handCard, player } = dragItem;
    const currentState = { ...gameState };

    // IMMEDIATE VALIDATION
    const validation = BuildValidator.canCreateBuild(handCard, targetCard, currentState, player);
    if (!validation.valid) {
      console.error(`[VALIDATION FAILED] ${validation.message}`);
      return currentState;
    }

    console.log(`[EXECUTE] Creating build(${validation.buildValue}) from ${handCard.rank}${handCard.suit} + ${targetCard.rank}${targetCard.suit}`);

    // ATOMIC STATE UPDATE - All changes happen immediately and together
    const updatedState = this.updateStateAtomically(currentState, handCard, targetCard, player, validation.buildValue);

    // LOG GAME STATE CHANGE
    this.logStateChange(`Player ${player + 1} built a ${validation.buildValue}`, updatedState);

    return updatedState;
  }

  static updateStateAtomically(gameState, handCard, tableCard, player, buildValue) {
    const newState = {
      ...gameState,
      playerHands: [...gameState.playerHands],
      tableCards: [...gameState.tableCards]
    };

    // Remove hand card
    newState.playerHands[player] = gameState.playerHands[player].filter(card =>
      !(card.rank === handCard.rank && card.suit === handCard.suit)
    );

    // Remove table card and add build
    const tableIndex = gameState.tableCards.findIndex(card =>
      !card.type && card.rank === tableCard.rank && card.suit === tableCard.suit
    );

    if (tableIndex !== -1) {
      newState.tableCards.splice(tableIndex, 1);
      const build = BuildFactory.createBuildFromCards(handCard, tableCard, player);
      newState.tableCards.push(build);
    }

    // Advance turn
    newState.currentPlayer = (gameState.currentPlayer + 1) % 2;

    return newState;
  }

  static logStateChange(description, gameState) {
    console.group(`%c${description}`, 'color: blue; font-weight: bold;');

    console.log('Table Cards:', gameState.tableCards.map(c =>
      c.type === 'build' ? `Build(${c.value})` : `${c.rank}${c.suit}`
    ));

    console.log('Player 1 Hand:', gameState.playerHands[0].map(c => `${c.rank}${c.suit}`));
    console.log('Player 2 Hand:', gameState.playerHands[1].map(c => `${c.rank}${c.suit}`));

    console.log('Player 1 Captures:', gameState.playerCaptures?.[0]?.length || 0);
    console.log('Player 2 Captures:', gameState.playerCaptures?.[1]?.length || 0);

    console.log(`Next turn: Player ${gameState.currentPlayer + 1}`);

    console.groupEnd();
  }
}

// ============================================================================
// MAIN DROP HANDLER - COORDINATES ALL COMPONENTS
// ============================================================================

function handleDropOnCard(dragItem, targetInfo, gameState) {
  const { card: draggedCard, player } = dragItem;
  const { cardId, rank, suit, type } = targetInfo;

  console.log(`ðŸŽ¯ DROP ON CARD: ${draggedCard.source || 'hand'} -> ${type || 'loose'}`, { draggedItem: dragItem, targetInfo });

  // IMMEDIATE VALIDATION - Single step, no modal
  if (type === 'build') {
    // Build-on-build logic (separate implementation)
    console.log(`ðŸŽ¯ BUILD DROP: Processing build drop for ${draggedCard.rank} on existing build`);
    return handleBuildDrop(dragItem, targetInfo, gameState);
  } else {
    // Card-on-card logic (creates new build)
    console.log(`ðŸŽ¯ CARD DROP: Player ${player + 1} dropping ${draggedCard.rank}${draggedCard.suit} onto loose card ${rank}${suit}`);

    const tableCard = gameState.tableCards.find(c => !c.type && c.rank === rank && c.suit === suit);
    if (!tableCard) {
      console.error('âŒ Target card not found on table');
      return gameState;
    }

    // IMMEDIATE EXECUTION - Single build creation, no confirmation needed
    return GameStateManager.executeBuild(dragItem, tableCard, gameState);
  }
}

// ============================================================================
// DEMONSTRATION EXAMPLE
// ============================================================================

function demonstrateBuildCreation() {
  console.log('=== BUILD CREATION DEMONSTRATION ===');

  // Initial game state
  const initialState = {
    playerHands: [
      [new Card('2', 'â™ '), new Card('4', 'â™£'), new Card('5', 'â™¥')],
      [new Card('3', 'â™¦'), new Card('7', 'â™ ')]
    ],
    tableCards: [new Card('3', 'â™¦')],
    playerCaptures: [[], []],
    currentPlayer: 1, // Player 2's turn
    round: 1
  };

  // Set up drop zones
  const dropZone = {
    id: 'loose-stack-3-â™¦',
    x: 363, y: 63, width: 64, height: 88,
    centerX: 395, centerY: 107,
    onDrop: (dragItem) => {
      // This would normally route through handleDropOnCard
      return true;
    }
  };

  const dragManager = new DragDropManager();
  dragManager.dropZones = [dropZone];

  console.log('INITIAL STATE:');
  GameStateManager.logStateChange('Game start', initialState);

  // Simulate the drag: Player 2 (index 1) drags 2â™  onto table's 3â™¦
  const dragItem = {
    card: new Card('2', 'â™ '),
    source: 'hand',
    player: 1
  };

  const targetInfo = {
    cardId: '3-â™¦',
    rank: '3',
    suit: 'â™¦',
    type: 'loose'
  };

  console.log('\n=== EXECUTING DROP: 2â™  on 3â™¦ ===');

  // Execute the build creation
  const newState = handleDropOnCard(dragItem, targetInfo, initialState);

  console.log('\n=== RESULT ===');
  console.log('âœ… Table now shows: Build(5)');
  console.log('âœ… Player 2 hand:', newState.playerHands[1].map(c => c.rank + c.suit));
  console.log('âœ… Current player:', newState.currentPlayer === 0 ? 'Player 1' : 'Player 2');

  return newState;
}

// Export for use in other files
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    DragDropManager,
    BuildValidator,
    BuildFactory,
    GameStateManager,
    handleDropOnCard,
    demonstrateBuildCreation
  };
}

// Run demonstration if executed directly
if (typeof require !== 'undefined' && require.main === module) {
  demonstrateBuildCreation();
}

demonstrateBuildCreation();
